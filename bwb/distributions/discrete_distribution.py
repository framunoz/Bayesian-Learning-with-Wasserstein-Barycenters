import numpy as np
import torch
from PIL import Image
# noinspection PyPackageRequirements
from pyro.distributions import Categorical

from bwb.config import config

__all__ = [
    "DiscreteDistribution",
    "DistributionDraw",
]


# noinspection PyAbstractClass
class DiscreteDistribution(Categorical):
    """
    Class that represent a discrete distribution, using de `Categorical` class provided by Pyro.
    """

    def __init__(
            self,
            pk, xk=None,
            validate_args=None,
    ):
        """
        Initializer.

        :param pk: Array of probabilities. If it is a Tensor type, the device shall be fixed by this parameter.
        :type pk: array_like
        :param xk: Support of the distribution. Optional.
        :type xk: array_like or None
        :param validate_args:
        """

        # Save pk and xk as tensor
        self.pk: torch.Tensor = torch.as_tensor(pk, dtype=config.dtype, device=config.device)

        xk = xk if xk is not None else range(len(self.pk))
        self.xk: torch.Tensor = torch.as_tensor(xk, device=config.device)

        if len(self.pk) != len(self.xk):
            raise ValueError(
                "The sizes of pk and xk does not coincide:"
                f" {len(self.pk)} != {len(self.xk)}")

        super().__init__(probs=self.pk, validate_args=validate_args)

    def enumerate_support_(self, expand=True):
        """Enumerates the original support ``xk`` and not its indices."""
        return self.xk[self.enumerate_support(expand)]

    def sample_(self, sample_shape=torch.Size([])):
        """Sample from the original support ``xk``."""
        return self.xk[self.sample(sample_shape)]


# noinspection PyAbstractClass
class DistributionDraw(DiscreteDistribution):
    """Distribution generated by a drawing, which is represented by a matrix."""

    def __init__(
            self,
            weights,
            shape,
    ):
        """
        Initialiser.

        :param weights: The weights of the distribution.
        :param shape: The shape of the image that represents the distribution.
        """

        # Get the shape information
        self.shape = shape
        if len(self.shape) != 2:
            raise ValueError("The shape must have dimension 2.")
        n, m = self.shape
        if n * m != len(weights):
            raise ValueError("The weights must be equals to n * m, where shape=(n, m).")

        # Get the support as coordinates
        indx = torch.arange(n * m, device=config.device).reshape(-1, 1)
        support = torch.cat((indx // m, indx % m), 1)

        super(DistributionDraw, self).__init__(pk=weights, xk=support)

    @classmethod
    def from_array(
            cls,
            grayscale,
    ):

        # Save the grayscales for create images
        grayscale: torch.Tensor = torch.as_tensor(
            grayscale,
            dtype=torch.uint8,  # Use uint8 for images
            device=config.device
        )

        # Get the shape information
        shape = tuple(grayscale.shape)
        if len(shape) != 2:
            raise ValueError("The 'grayscale' tensor must have dimension 2.")

        # Get the weights from the grayscale
        weights: torch.Tensor = grayscale / 255
        weights /= torch.sum(weights)
        weights = weights.reshape((-1,))

        return cls(weights=weights, shape=shape)

    @property
    def grayscale(self) -> np.ndarray:
        """A matrix representing the gray scale of the image."""
        grayscale_ = self.pk / torch.max(self.pk) * 255
        grayscale_ = grayscale_.reshape(self.shape).clone().detach()
        return grayscale_.to(torch.uint8).cpu().numpy()

    @property
    def image(self) -> Image.Image:
        """Representation of the Image.

        :return: An PIL.Image.Image instance.
        """
        return Image.fromarray(255 - self.grayscale)

    def __repr__(self):
        return type(self).__name__ + f"(shape: {self.shape})"

    def _repr_png_(self):
        """iPython display hook support

        :returns: png version of the image as bytes
        """
        # noinspection PyUnresolvedReferences,PyProtectedMember
        return self.image._repr_png_()

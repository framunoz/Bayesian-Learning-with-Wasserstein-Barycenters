import numpy as np
import torch
# noinspection PyPackageRequirements
import torch.distributions
from PIL import Image

from bwb import logging
from bwb.config import config
from bwb.utils import _grayscale
from bwb.validation import _shape_validation, _shape_weights_validation

__all__ = [
    "DiscreteDistribution",
    "DistributionDraw",
]

_log = logging.get_logger(__name__)


# noinspection PyAbstractClass
class DiscreteDistribution(torch.distributions.Categorical):
    """
    Class that represent a discrete distribution, using de `Categorical` class provided by Pyro.
    """

    def __init__(
            self,
            weights, support=None,
            validate_args=None,
    ):
        """
        Initializer.

        :param weights: Array of probabilities. If it is a Tensor type, the device shall be fixed
        by this parameter.
        :param support: Support of the distribution. Optional.
        :param validate_args:
        """

        # Save weights and support as tensor
        self.weights: torch.Tensor = torch.as_tensor(weights,
                                                     dtype=config.dtype,
                                                     device=config.device)

        support = support if support is not None else range(len(self.weights))
        self.original_support: torch.Tensor = torch.as_tensor(support, device=config.device)

        if len(self.weights) != len(self.original_support):
            raise ValueError(
                "The sizes of weights and support does not coincide:"
                f" {len(self.weights)} != {len(self.original_support)}")

        super().__init__(probs=self.weights, validate_args=validate_args)

        # Non zero mask
        self._nz_mask: torch.Tensor = self.probs.nonzero(as_tuple=True)

    @property
    def dtype(self) -> torch.dtype:
        """dtype of the instance."""
        return self.weights.dtype

    @property
    def device(self) -> torch.device:
        """device of the instance."""
        return self.weights.device

    def enumerate_support_(self, expand=True) -> torch.Tensor:
        """Enumerates the original support ``support`` and not its indices."""
        return self.original_support[self.enumerate_support(expand)]

    def sample_(self, sample_shape=torch.Size([])) -> torch.Tensor:
        """Sample from the original support ``support``."""
        return self.original_support[self.sample(sample_shape)]

    @property
    def nz_logits(self) -> torch.Tensor:
        """Non-zero logits."""
        return self.logits[self._nz_mask]

    @property
    def nz_probs(self) -> torch.Tensor:
        """Non-zero probs."""
        return self.probs[self._nz_mask]

    def enumerate_nz_support(self, expand=True) -> torch.Tensor:
        """Enumerate non-zero support."""
        return self.enumerate_support(expand)[self._nz_mask]

    def enumerate_nz_support_(self, expand=True) -> torch.Tensor:
        """Enumerate non-zero support using the original support."""
        return self.enumerate_support_(expand)[self._nz_mask]


# noinspection PyAbstractClass
class DistributionDraw(DiscreteDistribution):
    """Distribution generated by a drawing, which is represented by a matrix."""

    def __init__(self, support, weights, shape):
        """
        Initialiser.

        :param weights: The weights of the distribution.
        :param support: The positions of the weights.
        :param shape: The shape of the image that represents the distribution.
        """

        # Get the shape information
        self.shape = _shape_validation(shape, n_dim=2)
        self._grayscale = None  # For the cachÃ© of the grayscale

        super(DistributionDraw, self).__init__(weights=weights, support=support)

    @classmethod
    def from_weights(
            cls,
            weights,
            shape,
    ):
        """
        Build an instance from the weights and the shape, assuming that all weights correspond to
        an image coordinate.

        :param weights: The weights of the distribution.
        :param shape: The shape of the image that represents the distribution.
        :return: an instance of :py:class:`DistributionDraw`
        """
        n, m = _shape_weights_validation(shape, weights, n_dim=2)

        # Get the support as coordinates
        indx = torch.arange(n * m, device=config.device, dtype=config.dtype).reshape(-1, 1)
        support = torch.cat((indx // m, indx % m), 1)
        return cls(support, weights, shape)

    @classmethod
    def from_array(
            cls,
            grayscale,
    ):
        # Save the grayscales for create images
        grayscale: torch.Tensor = torch.as_tensor(
            grayscale,
            dtype=torch.uint8,  # Use uint8 for images
            device=config.device
        )

        # Get the shape information
        shape = _shape_validation(grayscale.shape, n_dim=2,
                                  msg="The 'grayscale' tensor must have dimension {n_dim}.")

        # Get the weights from the grayscale
        weights: torch.Tensor = grayscale / 255
        weights /= torch.sum(weights)
        weights = weights.reshape((-1,))

        to_return = cls.from_weights(weights=weights, shape=shape)

        to_return._grayscale = grayscale.cpu().numpy()

        return to_return

    @property
    @logging.register_total_time_method(_log)
    def grayscale(self) -> np.ndarray:
        """A matrix representing the gray scale of the image."""
        if self._grayscale is None:
            # Get the arrays as numpy
            shape = tuple(self.shape)
            weights = self.weights.cpu().numpy()
            support = self.original_support.cpu().numpy()
            # Compute the grayscale using Numba
            self._grayscale = _grayscale(shape, weights, support)

        return self._grayscale

    @property
    def image(self) -> Image.Image:
        """
        Representation of the Image.

        :return: A PIL.Image.Image instance.
        """
        return Image.fromarray(255 - self.grayscale)

    def __repr__(self):
        return type(self).__name__ + f"(shape: {self.shape})"

    def _repr_png_(self):
        """iPython display hook support

        :returns: png version of the image as bytes
        """
        # noinspection PyUnresolvedReferences,PyProtectedMember
        return self.image._repr_png_()

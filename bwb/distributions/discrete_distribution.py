import typing as t
import warnings

import torch

# noinspection PyPackageRequirements
import torch.distributions
import torchvision.transforms.functional as F
from PIL import Image

from bwb import logging
from bwb.config import config
from bwb.utils import _grayscale
from bwb.validation import _shape_validation

__all__ = [
    "IDistribution",
    "DiscreteDistribution",
    "DistributionDraw",
]

_log = logging.get_logger(__name__)


class IDistribution(t.Protocol):
    """
    Protocol for the discrete distributions, like the classes `DiscreteDistribution` and `DistributionDraw`.
    """

    @property
    def original_support(self) -> torch.Tensor:
        """Original support."""
        ...

    @property
    def dtype(self) -> torch.dtype:
        """dtype of the instance."""
        ...

    @property
    def device(self) -> torch.device:
        """device of the instance."""
        ...

    def enumerate_support_(self, expand=True) -> torch.Tensor:
        """Enumerates the original support ``support`` and not its indices."""
        ...

    def sample_(self, sample_shape=torch.Size([])) -> torch.Tensor:
        """Sample from the original support ``support``."""
        ...

    @property
    def nz_logits(self) -> torch.Tensor:
        """Non-zero logits."""
        ...

    @property
    def nz_probs(self) -> torch.Tensor:
        """Non-zero probs."""
        ...

    def enumerate_nz_support(self, expand=True) -> torch.Tensor:
        """Enumerate non-zero support."""
        ...

    def enumerate_nz_support_(self, expand=True) -> torch.Tensor:
        """Enumerate non-zero support using the original support."""
        ...


# noinspection PyAbstractClass
class DiscreteDistribution(torch.distributions.Categorical):
    """
    Class that represent a discrete distribution, using de `Categorical` class provided by Pyro.
    """

    def __init__(
        self,
        weights,
        support=None,
        validate_args=None,
    ):
        """
        Initializer.

        :param weights: Array of probabilities. If it is a Tensor type, the device shall be fixed
        by this parameter.
        :param support: Support of the distribution. Optional.
        :param validate_args:
        """

        # Save weights and support as tensor
        self.weights: torch.Tensor = torch.as_tensor(
            weights, dtype=config.dtype, device=config.device
        )

        self._original_support: t.Optional[torch.Tensor] = None
        if support is not None:
            self._original_support: torch.Tensor = torch.as_tensor(
                support, device=config.device
            )

        if support is not None and len(self.weights) != len(self._original_support):
            raise ValueError(
                "The sizes of weights and support does not coincide:"
                f" {len(self.weights)} != {len(self._original_support)}"
            )

        super().__init__(probs=self.weights, validate_args=validate_args)

        # Non zero mask
        self._nz_mask: torch.Tensor = self.probs.nonzero(as_tuple=True)

    @property
    def original_support(self) -> torch.Tensor:
        """Original support."""
        if self._original_support is None:
            self._original_support = torch.arange(
                len(self.weights), device=config.device
            )

        return self._original_support

    @property
    def dtype(self) -> torch.dtype:
        """dtype of the instance."""
        return self.weights.dtype

    @property
    def device(self) -> torch.device:
        """device of the instance."""
        return self.weights.device

    def enumerate_support_(self, expand=True) -> torch.Tensor:
        """Enumerates the original support ``support`` and not its indices."""
        return self.original_support[self.enumerate_support(expand)]

    def sample_(self, sample_shape=torch.Size([])) -> torch.Tensor:
        """Sample from the original support ``support``."""
        return self.original_support[self.sample(sample_shape)]

    @property
    def nz_logits(self) -> torch.Tensor:
        """Non-zero logits."""
        return self.logits[self._nz_mask]

    @property
    def nz_probs(self) -> torch.Tensor:
        """Non-zero probs."""
        return self.probs[self._nz_mask]

    def enumerate_nz_support(self, expand=True) -> torch.Tensor:
        """Enumerate non-zero support."""
        return self.enumerate_support(expand)[self._nz_mask]

    def enumerate_nz_support_(self, expand=True) -> torch.Tensor:
        """Enumerate non-zero support using the original support."""
        return self.enumerate_support_(expand)[self._nz_mask]


# noinspection PyAbstractClass
class DistributionDraw(DiscreteDistribution):
    """Distribution generated by a drawing, which is represented by a matrix."""

    def __init__(self, weights, shape, support=None):
        """
        Initialiser.

        :param weights: The weights of the distribution.
        :param support: The positions of the weights.
        :param shape: The shape of the image that represents the distribution.
        """

        # Get the shape information
        self.shape = _shape_validation(shape, n_dim=2)
        self._grayscale = None  # For the cache of the grayscale
        self._grayscale_weights = None  # For the cache of the grayscale weights

        super(DistributionDraw, self).__init__(weights=weights, support=support)

    @property
    def original_support(self) -> torch.Tensor:
        """Original support."""
        if self._original_support is None:
            n, m = self.shape
            indx = torch.arange(n * m, device=config.device, dtype=torch.int64).reshape(
                -1, 1
            )
            self._original_support = torch.cat((indx // m, indx % m), 1)

        return self._original_support

    @classmethod
    def from_weights(
        cls,
        weights,
        shape,
    ):
        """
        Build an instance from the weights and the shape, assuming that all weights correspond to
        an image coordinate.

        Deprecated: use the constructor instead.

        :param weights: The weights of the distribution.
        :param shape: The shape of the image that represents the distribution.
        :return: an instance of :py:class:`DistributionDraw`
        """
        msg = "This method is deprecated, use the constructor instead."
        warnings.warn(msg, DeprecationWarning, stacklevel=2)
        _log.warning(msg)
        return cls(weights, shape)

    @classmethod
    def from_discrete_distribution(cls, dd: DiscreteDistribution, shape):
        """Build an instance from a discrete distribution and the shape of the image."""
        return cls(support=dd.original_support, weights=dd.weights, shape=shape)

    @classmethod
    def from_grayscale_weights(
        cls,
        grayscale_weights,
    ):
        """Build an instance from the grayscale weights."""
        grayscale_weights: torch.Tensor = torch.as_tensor(
            grayscale_weights,
            dtype=config.dtype,
            device=config.device,
        ).squeeze()

        # Get the shape information
        shape = _shape_validation(
            grayscale_weights.shape,
            n_dim=2,
            msg="The 'grayscale_weights' tensor must have dimension {n_dim}.",
        )

        grayscale_weights /= torch.sum(grayscale_weights)
        weights = grayscale_weights.reshape((-1,))

        to_return = cls(weights=weights, shape=shape)

        to_return._grayscale_weights = grayscale_weights

        return to_return

    @classmethod
    def from_array(
        cls,
        grayscale,
    ):
        # Save the grayscales for create images
        grayscale: torch.Tensor = torch.as_tensor(
            grayscale, dtype=torch.uint8, device=config.device  # Use uint8 for images
        ).squeeze()

        # Get the shape information
        shape = _shape_validation(
            grayscale.shape,
            n_dim=2,
            msg="The 'grayscale' tensor must have dimension {n_dim}.",
        )

        # Get the weights from the grayscale
        grayscale_weights: torch.Tensor = grayscale / 255
        grayscale_weights /= torch.sum(grayscale_weights)
        weights = grayscale_weights.reshape((-1,))

        to_return = cls(weights=weights, shape=shape)

        to_return._grayscale = grayscale
        to_return._grayscale_weights = grayscale_weights

        return to_return

    @property
    @logging.register_total_time_method(_log)
    def grayscale(self) -> torch.Tensor:
        """A matrix representing the gray scale of the image."""
        if self._grayscale is not None:
            return self._grayscale

        if self._grayscale_weights is not None:
            grayscale = torch.clone(self._grayscale_weights)
            grayscale /= grayscale.max()
            grayscale *= torch.tensor(255, dtype=config.dtype, device=config.device)
            self._grayscale = torch.as_tensor(
                grayscale, dtype=torch.uint8, device=config.device
            )

        else:
            to_return = torch.zeros(
                self.shape, dtype=config.dtype, device=config.device
            )
            weights = self.weights
            support = self.original_support
            # Compute the grayscale
            self._grayscale = _grayscale(to_return, weights, support)

        return self._grayscale

    @property
    @logging.register_total_time_method(_log)
    def grayscale_weights(self) -> torch.Tensor:
        """A matrix representing the gray scale of the image as a probability weight."""
        if self._grayscale_weights is None:
            gs_weights = self.grayscale / 255
            gs_weights /= torch.sum(gs_weights)
            self._grayscale_weights = gs_weights

        return self._grayscale_weights

    @property
    def image(self) -> Image.Image:
        """
        Representation of the Image.

        :return: A PIL.Image.Image instance.
        """
        return F.to_pil_image(255 - self.grayscale)

    def __repr__(self):
        return type(self).__name__ + f"(shape: {self.shape})"

    def _repr_png_(self):
        """iPython display hook support

        :returns: png version of the image as bytes
        """
        # noinspection PyUnresolvedReferences,PyProtectedMember
        return self.image._repr_png_()
